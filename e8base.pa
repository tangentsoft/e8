/#E8# OS/8 EMACS CORE FUNCTIONS
/
/ THIS FILE IS OFFERED UNDER THE SIMH LICENSE; SEE THE COPYING.MD FILE.

	OCTAL
BELL=7		/ SPECIAL CHARACTERS
TAB=11
LF=12
CR=15
ESC=33
SP=40
BS=10

/ NEW LINE IN BUFFER. GENERALLY CAN BE ANY CONTROL CHAR,
/ BUT THERE IS ONE PLACE (INSF1) THAT ASSUMES IT'S CR: IN
/ FILE INPUT TO CONVERT CR/LF TO NL BY DISCARDING LF.
NL=CR

/ DISPLAY SCREEN DIMENSIONS. WD * (HT+1) MUST BE <= 3968 TO AVOID
/ RUNNING INTO OS/8 USE OF LAST PAGE OF FIELD 1
	DECIMAL
IFNDEF SCRWD <SCRWD=80>
IFNDEF SCRHT <SCRHT=42>
TXTHT=SCRHT-2	/ SCREEN HEIGHT MINUS MODE LINES
	OCTAL	

/ FIELD DEFINITIONS
IFNDEF MEMSIZ <MEMSIZ=10>
BUFFLD=CDF 20		/ TEXT BUFFER START
ENDFLD=MEMSIZ^10+CDF	/ TEXT BUFFER END
CODFLD=CDF 0		/ CODE
SCRFLD=CDF 10		/ SCREEN COPY

/ ASSERTION FAILURE
FAIL=JMS I [ASSERT

/ PAGE 0

	*10
SRCP,	0	/ AUTOINDEX USED IN SOME LOOPS
DSTP,	0
TMP0,	0
TMP1,	0

	*20
BUF,	0; BUFFLD	/ START OF TEXT BUFFER
BUFEND,	0; ENDFLD	/ END OF TEXT BUFFER
POINT,	0; ENDFLD	/ INSERT/DELETE POINT (END OF GAP)
MARK,	0; BUFFLD	/ SEE COMMENTS IN EE.PA
TOS,	0; BUFFLD	/ TOP OF SCREEN
GAP,	0; BUFFLD	/ START OF GAP
SRCHP,	0; 0		/ SEARCH POINTER

CHANGD,	0  		/ NON-ZERO IF FILE HAS CHANGED
MLHOLD,	0		/ HOLD MODE LINE FOR ONE CYCLE
MKFLAG,	0		/ MARK BEFORE (0) OR AFTER (1) POINT
AC24,	0; 0		/ 24-BIT ACCUMULATOR
DSKEP,	0  		/ DSK HANDLER ENTRY POINT

SRCHC,	0  		/ SFWD, SREV CHARACTER
GOSTOP,	0; 0		/ END ADDRESS FOR MOVING FWD, REV

/ A ZONE (ENTIRE BUFFER OR JUST REGION) FOR WRITING TO A FILE
WRBEG,	0	/ POINTER TO 15-BIT BEGINNING BELOW GAP
WREND,	0	/ POINTER TO 15-BIT END ABOVE POINT
WRNAME,	0	/ POINTER TO FILENAME
WRSIZE,	0	/ FILE SIZE IN OS/8 BLOCKS (256 WORDS)

/ VARIABLES NEED FOR SCREEN UPDATE. ON PAGE 0 SINCE THE CODE SPANS
/ MULTIPLE PAGES
ROW,	0	/ SCREEN POSITION DURING UPDATE
COL,	0
CURROW,	0	/ POSITION OF POINT (CURSOR) FOUND DURING UPDATE
CURCOL,	0
BUFP,	0	/ POINTER INTO BUFFER (FIELD BITS AT RNDFLD)
SCRLIN,	0	/ POINTER TO CURRENT SCREEN LINE
SCRP,	0  	/ POINTER INTO SCREEN COPY IN FIELD 1
RNDP,	0	/ POINTER INTO RENDER BUFFER IN FIELD 1
RNDFLG,	0	/ RENDERING BEFORE (0) OR AFTER (1) GAP
RNDESC,	0	/ NEGATIVE GAP OR BUFEND ADDRESS

/ TEMP REGISTERS USED BY 15-BIT ADDRESS ROUTINES
A15,	0
B15,	0
C15,	0

/ USED TO RECOVER DELETED CHARS
RCVPT,	0; ENDFLD	/ POINT RECOVER ZONE
RCVGP,	0; BUFFLD	/ GAP RECOVER ZONE
LASTPT,	0; ENDFLD	/ PREVIOUS POINT
LASTGP,	0; BUFFLD	/ PREVIOUS GAP

/ LARGE COMMON LITERAL TABLE HERE

/ TOP LEVEL
	*200	/------------
	TLS
	JMS SCINIT
	JMS IOINIT
	JMP 7600	/ FILE SYS ERR, QUIT

TOP,	TAD MLHOLD	/ CLEAR MODE LINE TEXT UNLESS BEING HELD
	SNA CLA
	JMS CLRMLT
	DCA MLHOLD
	JMS FIXMRK	/ FIX MARK IF NECESSARY
	JMS RCZONE	/ MAINTAIN RECOVER ZONE
	JMS UPDATE	/ UPDATE SCREEN

	JMS RDTTY	/ GET AND PROCESS CHAR INPUT
	TAD [-SP
	SPA
	JMP CTRL
	
	TAD [SP		/ NORMAL CHARACTER, INSERT
	JMS INSERT
	JMP ERR
	JMP TOP

/ CONTROL CHAR
CTRL,	TAD [SP
	TAD (CTABLE
ALTEX,	DCA CMD
	TAD I CMD
	SNA
	JMP ERR
	DCA CMD
	JMS I CMD
	JMP ERR
	JMP TOP

/ ERROR
ERR,	TAD (BELL
	JMS WRTTY
	JMP TOP

/ ALT PREFIX (ESCAPE SEQUENCE START)
ALTPRE,	0
	JMS RDTTY
	JMS UPPER
	AND [77
	TAD (ALTTBL
	JMP ALTEX

/ ^X COMMANDS. CONTROL, UPPER, AND LOWER CASE LETTERS ARE ALL
/ THE SAME, DUE TO SOME CONTROL CHARS BEING INTERCEPTED BY
/ LINUX, MOBAXTERM, OR SIM
CTRLX,	0
	TAD (30
	JMS WRMLT
	JMS UPDATE
	
	JMS RDTTY
	AND (37
	TAD (XTABLE
	JMP ALTEX

CMD,	0

/ SOME CONTROL CHARS ARE JUST INSERTED
INSTAB,	0
	TAD [TAB
	JMS INSERT
	SKP
	ISZ INSTAB
	JMP I INSTAB

NEWLN,	0
	TAD [NL
	JMS INSERT
	SKP
	ISZ NEWLN
	JMP I NEWLN

/ LF = NL, TAB
NLTAB,	0
	JMS NEWLN
	JMP I NLTAB
	JMS INSTAB
	JMP I NLTAB
	ISZ NLTAB
	JMP I NLTAB

/ READ QUOTED CHARACTER
GETQ,	0
	TAD (21
	JMS WRMLT
	JMS UPDATE
	JMS RDTTY
	JMP I GETQ
	
/ QUOTED INSERT
QUOTE,	0
	JMS GETQ
	JMS INSERT
	SKP
	ISZ QUOTE
	JMP I QUOTE

/ ALT-Q. LIKE ^Q, BUT REGULAR LETTERS ARE INTERPRETED AS CTRL
/ DUE TO SOME CTRL CHARS BEING INTERCEPTED
AQUOTE,	0
	JMS GETQ
	TAD (-100
	SMA
	JMP AQA
	CLA
	JMP I AQUOTE
AQA,	AND (37
	JMS INSERT
	JMP I AQUOTE
	ISZ AQUOTE
	JMP I AQUOTE

/ EXIT TO OS/8
EXIT,	0
	JMS OFFER
	JMP I EXIT

IFDEF FSCROL <
	TAD [ESC
	JMS WRTTY
	TAD (143
	JMS WRTTY
>
IFNDEF FSCROL <
	TAD (SCRHT-1
	DCA ROW
	DCA COL
	JMS SETCUR
>
	JMP 7600

	PAGE	/------------ 0400

CTABLE,	SETMRK;	BEGLN;	BACK;	0;	DELFWD;	ENDLN;	FWD;	0
	DELREV;	INSTAB;	NLTAB;	KEOL;	REDRAW;	NEWLN;	NXTLN;	OPEN
	PRVLN;	QUOTE;	0;	ISRCH;	0;	0;	FWDSCR;	DELREG
	CTRLX;	YANK;	EXIT;	ALTPRE;	SCRLUP;	0;	0;	0

ALTTBL,	0;	BEGLN;	BACKWD;	0;	DLFWWD;	ENDLN;	FWDWD;	0
	DLRVWD;	0;	0;	0;	0;	0;	SCHNXT;	0
	0;	AQUOTE;	RECOVR;	ISRCH;	0;	0;	REVSCR;	WRREG
	0;	0;	0;	KEYS;	SCRLDN;	0;	0;	0

	0;	0;	0;	0;	0;	QREPL;	0;	0
	0;	0;	0;	0;	0;	0;	0;	0
	0;	0;	0;	0;	0;	0;	0;	0
	0;	0;	0;	0;	GOBEG;	0;	GOEND;	0

XTABLE,	0;	0;	0;	0;	0;	0;	FFILE;	0
	0;	INFILE;	0;	0;	0;	0;	0;	0
	0;	0;	RDMORE;	SVFILE;	0;	0;	0;	WRFILE
	EXGPM;	0;	0;	0;	0;	0;	0;	0

	
	PAGE	/------------ 0600
/ CHARACTER I/O

RDTTY,	0
	KSF
	JMP .-1
	KRB
	AND (177

	TAD (-177	/ CONVERT DELETE TO BACKSPACE TO HANDLE
	SNA		/ MODERN ENTER KEY, WHICH MIGHT SEND
	TAD (BS-177	/ EITHER	
	TAD (177
	JMP I RDTTY

WRTTY,	0
	TSF
	JMP .-1
	TLS
	CLA
	JMP I WRTTY

/ WRITE 0-TERMINATED STRING TO SUBROUTINE WHOSE
/ ADDRESS FOLLOWS JMS
WRSTR,	0
	DCA WRSTRP
	TAD I WRSTR
	DCA WRSUB
	ISZ WRSTR
	
WRSTRA,	TAD I WRSTRP
	SNA
	JMP I WRSTR
	ISZ WRSTRP
	JMS I WRSUB
	JMP WRSTRA
WRSTRP,	0

/ WRITE AC DECIMAL, UNSIGNED, TO SUBROUTINE WHOSE
/ ADDRESS FOLLOWS JMS
WRDEC,	0
	DCA AC24
	DCA AC24+1
	TAD (W10BUF		/ SET UP BUFFER
	DCA W10P
	TAD I WRDEC		/ GET SUBROUTINE
	DCA WRSUB
	ISZ WRDEC

WRDECA,	TAD [12			/ NEXT DIGIT, REVERSE ORDER
	JMS DIVIDE
	TAD AC24+1
	TAD ["0
	DCA I W10P
	ISZ W10P
	DCA AC24+1
	TAD AC24
	SZA CLA
	JMP WRDECA

WRDECB,	STA			/ WRITE DIGITS IN REVERSE
	TAD W10P
	DCA W10P
	TAD I W10P
	JMS I WRSUB
	TAD W10P
	TAD (-W10BUF
	SZA CLA
	JMP WRDECB

	JMP I WRDEC

W10P,	0
W10BUF,	ZBLOCK 4
WRSUB,	0

W8CNT=W10P
W8NUM=W10BUF

/ WRITE AC OCTAL, UNSIGNED, TO SUBROUTINE WHOSE
/ ADDRESS FOLLOWS JMS.
WROCT,	0
	DCA W8NUM
	TAD I WROCT
	DCA WRSUB
	ISZ WROCT
	TAD (-4
	DCA W8CNT
WROCTA,	TAD W8NUM
	CLL RTL; RAL
	DCA W8NUM
	TAD W8NUM
	RAL
	AND [7
	TAD ["0
	JMS I WRSUB
	ISZ W8CNT
	JMP WROCTA
	JMP I WROCT

/ INSERT AC AT POINT
INSERT,	0
	DCA C15			/ BUFFER FULL (GAP == POINT)?
	TAD [GAP
	JMS SNE15; POINT
	JMP INSFUL
	ISZ INSERT

	TAD C15			/ NO, CHAR GOES IN GAP
	JMS PUT15; GAP
	TAD [GAP
	JMS INC15
	STA
	DCA CHANGD
	JMP I INSERT

INSFUL,	TAD (FULMSG		/ BUFFER FULL
	JMS WR6
	WRMLT
	ISZ MLHOLD
	JMP I INSERT
FULMSG,	TEXT / BUFFER FULL!/

/ 15-BIT POINTERS ARE TWO WORDS, ADDRESS FOLLOWED BY CDF THAT
/ HOLDS FIELD.

/ INCREMENT 15-BIT POINTER.
INC15,	0
	DCA A15
	ISZ I A15
	JMP I INC15
	ISZ A15
	TAD I A15
	TAD [10
	DCA I A15
	JMP I INC15
	
	PAGE	/------------ 1000

/ DECREMENT 15-BIT POINTER
DEC15,	0
	DCA A15
	STA STL
	TAD I A15
	DCA I A15
	SNL
	JMP I DEC15
	ISZ A15
	TAD I A15
	TAD [-10
	DCA I A15
	JMP I DEC15

/ FETCH FROM 15-BIT POINTER
GET15,	0
	DCA A15
	TAD I A15
	DCA B15
	ISZ A15
	TAD I A15
	DCA .+1
	0
	TAD I B15
	CODFLD
	JMP I GET15

/ STORE AC AT 15-BIT POINTER WHOSE ADDRESS FOLLOWS JMS
PUT15,	0
	DCA C15
	TAD I PUT15
	ISZ PUT15
	DCA A15
	TAD I A15
	DCA B15
	ISZ A15
	TAD I A15
	DCA .+1
	0
	TAD C15
	DCA I B15
	CODFLD
	JMP I PUT15

/ SKIP IF TWO 15-BIT POINTERS ARE NOT EQUAL. AC AND FOLLOWING WORD
/ HAVE ADDRESS OF THE POINTERS
SNE15,	0
	DCA A15
	TAD I SNE15
	ISZ SNE15
	DCA B15

	TAD I A15
	CIA
	TAD I B15
	SZA CLA
	JMP SNE15A

	ISZ A15
	ISZ B15
	TAD I A15
	CIA
	TAD I B15
	SZA CLA
SNE15A,	ISZ SNE15
	JMP I SNE15

/ MOVE POINT FORWARD 1, SKIP IF OK
FWD,	0
	TAD [POINT		/ OK TO MOVE?
	JMS SNE15; BUFEND
	JMP I FWD
	ISZ FWD			/ YES, SKIP RETURN
	
	JMS SFWDPT		/ MOVE ONE FORWARD
	TAD [SRCHP
	JMS INC15
	JMS GOFWD
	JMP I FWD

/ MOVE POINT BACK 1, SKIP IF OK
BACK,	0
	TAD [BUF		/ OK TO MOVE?
	JMS SNE15; GAP
	JMP I BACK
	ISZ BACK		/ YES, SKIP RETURN

	JMS SREVGP
	TAD [SRCHP
	JMS DEC15
	JMS GOREV
	JMP I BACK
/#EA#

/ DELETE FORWARD
DELFWD,	0
	TAD [POINT		/ AT END (POINT == BUFEND)?
	JMS SNE15; BUFEND
	JMP I DELFWD
	ISZ DELFWD

	TAD [POINT		/ NO, JUST INCREMENT POINY
	JMS INC15
	STA
	DCA CHANGD

	JMP I DELFWD

/ DELETE REVERSE
DELREV,	0			/ BACK ONE AND THEN DELETE FORWARD
	JMS BACK
	JMP I DELREV
	JMS DELFWD
	FAIL
	ISZ DELREV
	JMP I DELREV

/ BEGINNING OF BUFFER. ASSUME BUFFER STARTS AT ADDRESS 0 IN SOME FIELD.
GOBEG,	0
	DCA SRCHP		/ SRCHP = BEGINNING OF BUFFE
	TAD [BUFFLD
	DCA SRCHP+1
	JMS GOREV		/ GO THERE
	ISZ GOBEG
	JMP I GOBEG

/ END OF BUFFER. ASSUME BUFFER ENDS AT ADDRESS 0 IN SOME FIELD
/ (INCLUDING IMAGINARY FIELD 10)
GOEND,	0
	DCA SRCHP		/ SRCHP = END OF BUFFER
	TAD [ENDFLD
	DCA SRCHP+1
	JMS GOFWD		/ GO THERE
	ISZ GOEND
	JMP I GOEND

/ OPEN NEW LINE
OPEN,	0
	JMS NEWLN
	JMP I OPEN
	JMS BACK
	FAIL
	ISZ OPEN
	JMP I OPEN

 	PAGE	/------------ 1200

/ END OF LINE
ENDLN,	0
	ISZ ENDLN		/ CAN'T FAIL
	JMS SFWDPT		/ SEARCH FORWARD FOR NL
	TAD [NL
	JMS SFWD
	JMP ENDLNA
	JMS GOFWD		/ FOUND GO THERE
	JMP I ENDLN
ENDLNA,	JMS GOEND		/ NOT FOUND, GO TO END
	FAIL 			/ CAN'T FAIL
	JMP I ENDLN
	
/ NEXT LINE
NXTLN,	0
	JMS SFWDPT		/ SEARCH FORWARD FOR NL
	TAD [NL
	JMS SFWD
	JMP I NXTLN
	TAD [SRCHP		/ SKIP OVER NL
	JMS INC15
	JMS GOFWD		/ GO THERE
	ISZ NXTLN
	JMP I NXTLN

/ BEGINNING OF LINE
BEGLN,	0
	ISZ BEGLN		/ CAN'T FAIL
	JMS SREVGP		/ SEARCH BACK FOR NL
	TAD [NL
	JMS SREV
	JMP BEGLNA
	TAD [SRCHP		/ SKIP OVER NL
	JMS INC15
	JMS GOREV		/ GO THERE
	JMP I BEGLN
BEGLNA,	JMS GOBEG		/ NOT FOUND, GO TO BEGINNING
	FAIL
	JMP I BEGLN

/ PREVIOUS LINE
PRVLN,	0
	JMS SREVGP		/ SEARCH REVERSE FOR NL
	TAD [NL
	JMS SREV
	JMP I PRVLN
	JMS GOREV		/ GO THERE
	JMS BEGLN		/ THEN TO BEGINNING OF THAT LINE
	FAIL
	ISZ PRVLN
	JMP I PRVLN

/ SEARCH FORWARD FROM SRCHP FOR CHAR IN AC. IF FOUND UPDATE SRCHP
/ AND SKIP. SRCHP >= POINT. FOR SPEED, DON'T USE 15-BIT ADDRESS
/ SUBROUTINES
SFWD,	0
	CIA
	DCA SRCHC
	TAD SRCHP+1
	DCA SFWDF

SFWDA,	TAD SRCHP	/ DONE (SRCHP == BUFEND)?
	SZA CLA
	JMP SFWDF
	TAD SFWDF
	TAD [-ENDFLD
	SNA CLA
	JMP SFWDC
	
SFWDF,	0		/ NOT DONE, MATCH?
	TAD I SRCHP
	TAD SRCHC
	SNA CLA
	JMP SFWDB
	ISZ SRCHP	/ NO MATCH, SRCHP++
	JMP SFWDA
	TAD SFWDF
	TAD [10
	DCA SFWDF
	JMP SFWDA

SFWDB,	TAD SFWDF	/ MATCH, STORE FINAL FIELD
	DCA SRCHP+1
	ISZ SFWD
SFWDC,	CODFLD
	JMP I SFWD

/ SEARCH REVERSE FROM SRCHP-1 FOR CHAR IN AC. IF FOUND UPDATE SRCHP
/ AND SKIP. SRCHP <= GAP. FOR SPEED, DON'T USE 15-BIT ADDRESS
/ SUBROUTINES
SREV,	0
	CIA
	DCA SRCHC
	TAD SRCHP+1
	DCA SREVF

SREVA,	TAD SRCHP	/ DONE (SRCHP == BUF)
	SZA CLA
	JMP SREVC
	TAD SREVF
	TAD [-BUFFLD
	SNA CLA
	JMP SREVD
	
SREVC,	STA STL		/ NOT DONE, --SRCHP
	TAD SRCHP
	DCA SRCHP
	SNL CLA
	JMP SREVF
	TAD SREVF
	TAD [-10
	DCA SREVF

SREVF,	0		/ MATCH?
	TAD I SRCHP
	TAD SRCHC
	SZA CLA
	JMP SREVA

SREVB,	TAD SREVF	/ YES
	DCA SRCHP+1
	ISZ SREV
SREVD,	CODFLD
	JMP I SREV

/ ASSERTION FAILURE, FATAL ERROR
ASSERT,	0
	TAD (FAILMS
	JMS WR6
	WRTTY
	TAD ASSERT
	JMS WROCT
	WRTTY
	JMP 7600

 	PAGE	/------------ 1400

/ SET UP TO SEARCH FORWARD FROM POINT
SFWDPT,	0
	TAD POINT
	DCA SRCHP
	TAD POINT+1
	DCA SRCHP+1
	JMP I SFWDPT

/ SET UP TO SEARCH REVERSE FROM GAP
SREVGP,	0
	TAD GAP
	DCA SRCHP
	TAD GAP+1
	DCA SRCHP+1
	JMP I SREVGP

/ GO FORWARD FROM POINT TO SRCHP. POINT <= SRCHP <= BUFEND.
/ THIS IS POTENTIALLY THE SLOWEST EDIT OPERATION, SINCE IT
/ CAN MOVE LOTS OF CHARACTERS, SO DON'T USE 15-BIT ADDRESS
/ SUBROUTINES. 20 CYCLES = 30 US PER CHARACTER (8/I).
GOFWD,	0
	TAD SRCHP		/ GET -STOP ADDRESS
	CIA
	DCA GOSTOP
	TAD SRCHP+1
	CIA
	DCA GOSTOP+1
 
	TAD POINT+1		/ SET UP CDF INSTRUCTIONS
	DCA GOFWDP
	TAD GAP+1
	DCA GOFWDG

GOFWDA,	TAD POINT		/ AT STOP POINT?
	TAD GOSTOP
	SZA CLA
	JMP GOFWDP
	TAD GOFWDP
	TAD GOSTOP+1
	SZA CLA
	JMP GOFWDP
	
	CODFLD			/ YES, UPDATE POINT AND GAP
	TAD GOFWDP		
	DCA POINT+1
	TAD GOFWDG
	DCA GAP+1
	JMP I GOFWD		/ AND DONE

GOFWDP,	0     			/ MOVE CHAR FROM POINT TO GAP
	TAD I POINT
GOFWDG,	0
	DCA I GAP

	ISZ POINT		/ ++POINT
	JMP GOFWDB
	TAD GOFWDP
	TAD [10
	DCA GOFWDP
GOFWDB,	ISZ GAP			/ ++GAP
	JMP GOFWDA
	TAD GOFWDG
	TAD [10
	DCA GOFWDG

	JMP GOFWDA		/ NEXT

/ GO BACKWARDS FROM GAP TO SRCHP. BUF <= SRCHP <= GAP
/ 29 CYCLES = 43.5 US PER CHARACTER (8/I)
GOREV,	0
	TAD SRCHP		/ GET -STOP ADDRESS
	CIA
	DCA GOSTOP
	TAD SRCHP+1
	CIA
	DCA GOSTOP+1
	
	TAD POINT+1		/ SET UP CDF INSTRUCTIONS
	DCA GOREVP
	TAD GAP+1
	DCA GOREVG

GOREVA,	TAD GAP			/ AT STOP POINT?
	TAD GOSTOP
	SZA CLA
	JMP GOREVC
	TAD GOREVG
	TAD GOSTOP+1
	SZA CLA
	JMP GOREVC

	CODFLD			/ YES, UPDATE POINT AND GAP
	TAD GOREVP
	DCA POINT+1
	TAD GOREVG
	DCA GAP+1
	JMP I GOREV		/ DONE

GOREVC,	STA STL			/ --POINT
	TAD POINT
	DCA POINT
	SNL
	JMP GOREVB
	TAD GOREVP
	TAD [-10
	DCA GOREVP

GOREVB,	STA STL			/ --GAP
	TAD GAP
	DCA GAP
	SNL
	JMP GOREVG
	TAD GOREVG
	TAD [-10
	DCA GOREVG

GOREVG,	0			/ MOVE CHAR FROM GAP TO POINT
	TAD I GAP
GOREVP,	0
	DCA I POINT
	JMP GOREVA

/ COMPUTE NUMBER OF CHARS IN BUFFER, PUT IN AC24
BUFSIZ,	0
	TAD [BUFEND
	JMS LD24
	TAD [BUF
	JMS SUB15
	TAD [POINT
	JMS SUB15
	TAD [GAP
	JMS ADD15
	JMS FIX24
	JMP I BUFSIZ

/#EB# UPDATE SCREEN, MODE LINE

	PAGE	/------------ 1600

RMARK=STA CLL RAL    / END OF REDNER BUF MARKER = -2
RNDBUF=SCRWD^SCRHT   / LOCATION OF RENDER BUFFER (ONE SCRWD LINE)
RNDEND=RNDBUF+SCRWD

/ CLEAR RENDER BUFFER, COL = 0
RNDINI,	0
	DCA COL
	TAD (RNDBUF
	DCA RNDP
	JMP I RNDINI

/ END RENDER LINE
RNDFIN,	0
	RMARK			/ MARK END (-2)
	SCRFLD
	DCA I RNDP
	CODFLD
	JMP I RNDFIN

/ RENDER CURRENT LINE OF TEXT BUFFER TO RENDER BUFFER
RENDER,	0
	JMS RNDINI
	TAD (-SCRWD+1
	DCA RNDLIM

RNDA,	TAD BUFP		/ POSSIBLE GAP OR END?
	TAD RNDESC
	SNA CLA
	JMP RNDB

RNDFLD,	0			/ FETCH CHAR FROM TEXT BUFFER
	TAD I BUFP
	ISZ BUFP		/ UPDATE BUFFER POINTER
	JMP RNDG
	DCA RNDTMP
	TAD RNDFLD
	TAD [10
	DCA RNDFLD
	TAD RNDTMP

RNDG,	TAD (-40		/ CONTROL CHAR?
	SCRFLD
	SPA
	JMP RNDC

	TAD (40			/ NO, PUT IN BUFFER
	DCA I RNDP
	ISZ RNDP
	ISZ RNDLIM		/ DID IT FIT?
	JMP RNDA

RNDZ,	STA			/ NO, BACK UP
	DCA RNDLIM
	STA
	TAD RNDP
	DCA RNDP
	JMP RNDA

RNDB,	TAD RNDFLG		/ LOOKING FOR GAP OR END OF BUFFER?
	SZA CLA
	JMP RNDE
	TAD RNDFLD		/ SKIP OVER GAP?
	CIA
	TAD GAP+1
	SZA CLA
	JMP RNDFLD

	TAD POINT		/ YES, SKIP OVER GAP
	DCA BUFP
	TAD POINT+1
	DCA RNDFLD
	TAD ROW			/ SAVE CURSOR POSITION
	DCA CURROW
	TAD RNDLIM
	TAD (SCRWD-1
	DCA CURCOL

	ISZ RNDFLG		/ SET FLAG TO LOOK FOR END OF BUFFER
	DCA RNDESC
	TAD BUFP		/ END OF BUFFER ADDRESS IS 0
	SZA CLA
	JMP RNDFLD

RNDE,	TAD RNDFLD		/ END OF BUFFER?
	CIA
	TAD BUFEND+1
	SZA CLA
	JMP RNDFLD
	JMP RNDX		/ YES, DONE

RNDC,	TAD (40-TAB		/ TAB?
	SZA
	JMP RNDF
	TAD RNDLIM		/ YES, GET NUMBER OF SPACES TO WRITE
	TAD (SCRWD-1
	AND [7
	TAD (7770
	DCA RNDTMP
RNDD,	TAD [40			/ NEXT SPACE
	DCA I RNDP
	ISZ RNDP
	ISZ RNDLIM		/ DID IT FIT?
	SKP
	JMP RNDZ
	ISZ RNDTMP
	JMP RNDD
	JMP RNDA

RNDF,	TAD (TAB-NL		/ END OF LINE?
	SNA
	JMP RNDX

	TAD (NL+100		/ CONTROL CHAR
	DCA RNDTMP
	TAD (136		/ ^
	DCA I RNDP
	ISZ RNDP

	ISZ RNDLIM		/ DID IT FIT?
	SKP
	JMP RNDZ

	TAD RNDTMP		/ YES, CHAR
	DCA I RNDP
	ISZ RNDP	
	ISZ RNDLIM
	JMP RNDA
	JMP RNDZ
	
RNDX,	JMS RNDFIN		/ MARK END OF BUFFER
	JMP I RENDER

RNDLIM,	0
RNDTMP,	0

	PAGE  /------------------ 2000

/ WRITE RENDERED LINE TO SCREEN. COMPARE TO SCREEN COPY, BE
/ FRUGAL IN WRITING CHARACTERS TO TTY
WRSCR,	0
	TAD SCRLIN		/ SCREEN COPY ADDRESS
	DCA SCRP
	JMS RNDINI		/ CLEAR RENDER BUFFER
	DCA WRFLAG		/ FLAG = FALSE
	SCRFLD

WRSCRA,	TAD I RNDP		/ SCAN FOR MISMATCH
	CIA   			/ END OF LINE IS ALWAYS A MISMATCH
	TAD I SCRP
	SZA CLA
	JMP WRSCRB
	ISZ COL
	ISZ RNDP
	ISZ SCRP
	JMP WRSCRA

WRSCRB,	TAD I RNDP		/ END OF BOTH?
	AND I SCRP
	CODFLD
	SPA CLA
	JMP I WRSCR		/ YES, DONE
	JMS SETCUR		/ NO, SET CURSOR TO BEGIN FIXING

WRSCRD,	SCRFLD
	TAD I SCRP		/ END OF SCREEN LINE?
	SPA CLA
	ISZ WRFLAG		/ YES, SET FLAG
	TAD I RNDP		/ END OF RENDERED LINE?
	SPA
	JMP WRSCRC
	DCA I SCRP		/ NO, UPDATE SCREEN
	TAD I RNDP
	CODFLD
	JMS WRTTY
	ISZ COL
	ISZ RNDP
	ISZ SCRP
	JMP WRSCRD

WRSCRC,	STA			/ END OF RENDERED LINE, MARK SCREEN
	DCA I SCRP
	CODFLD
	TAD WRFLAG		/ CLEAR TO END OF LINE IF NECESSARY
	SZA CLA
	JMP I WRSCR
	TAD (CLREOL
	JMS WRSTR
	WRTTY
	JMP I WRSCR

CLREOL,	ESC; "[; "K; 0
WRFLAG,	0			/ ZERO MEANS OLD LINE LONGER THAN NEW

/ NEXT SCREEN ROW. SKIP IF NO CHARACTERS WAITING
NXTROW,	0
	ISZ ROW
	TAD SCRLIN
	TAD [SCRWD
	DCA SCRLIN
	KSF
	ISZ NXTROW
	JMP I NXTROW

/ UPDATE SCREEN
UPDATE, 0
	JMS SETTOS		/ SET TOP OF SCREEN

	DCA SCRLIN		/ INITIALIZATIONS
	DCA SCRP
	DCA ROW

	DCA RNDFLG		/ START BEFORE GAP
	TAD GAP
	CIA
	DCA RNDESC

	TAD TOS			/ BUFP = TOS
	DCA BUFP
	TAD TOS+1
	DCA RNDFLD
	
UPDA,	JMS RENDER		/ RENDER AND WRITE TEXT BUFFER
	JMS WRSCR
	JMS NXTROW
	JMP UPDB
	TAD ROW
	TAD [-TXTHT		/ LEAVE ROOM FOR STATUS LINES
	SZA CLA
	JMP UPDA

	JMS RMODE		/ RENDER AND WRITE MODE LINE
	JMS WRSCR
	JMS NXTROW
	JMP UPDB
	JMS RNDMLT
	JMS WRSCR

	TAD CURROW		/ SET CURSOR AT POINT
	DCA ROW
	TAD CURCOL
	DCA COL
	JMS SETCUR

UPDB,	JMP I UPDATE

/ SET SCREEN CURSOR USING ROW, COL
SETCUR,	0
	TAD [ESC
	JMS WRTTY
	TAD ("[
	JMS WRTTY
	TAD ROW
	IAC
	JMS WRDEC
	WRTTY
	TAD (";
	JMS WRTTY
	TAD COL
	IAC
	JMS WRDEC
	WRTTY
	TAD ("H
	JMS WRTTY
	JMP I SETCUR

	PAGE  /-------------------------- 2200

/ RENDER MODE LINES
RMODE,	0
	JMS RNDINI		/ BASE MODE LINE
	TAD (MLBASE
	JMS WR6
	WRRND
	JMS RNDFIN	

	TAD CHANGD		/ INDICATE BUFFER CHANGED
	SNA CLA
	JMP RMODEB
	TAD (RNDBUF+1
	DCA RNDP
	TAD (CHGMSG
	JMS WR6
	WRRND

RMODEB,	TAD (RNDBUF+5		/ FILE NAME
	DCA RNDP
	TAD FILENM+3		/ SAVE EXTENSION
	DCA RMODET
	DCA FILENM+3
	TAD (FILENM
	JMS WR6
	WRRND
	TAD (".
	JMS WRRND
	TAD RMODET
	DCA FILENM+3
	TAD (FILENM+3
	JMS WR6
	WRRND

	JMS BUFSIZ		/ BUFFER SIZE IN AC24
	TAD (RNDBUF+23		/ POINTER TO LSD OF DECIMAL SIZE
	DCA RNDP

RMODEA,	TAD [12			/ WRITE DECIMAL TO RENDER BUFFER
	JMS DIVIDE		/ IN REVERSE. WORKS FOR SIZE < 100000
	TAD AC24+1
	TAD ["0	
	SCRFLD
	DCA I RNDP
	CODFLD
	STA
	TAD RNDP
	DCA RNDP
	DCA AC24+1
	TAD AC24
	SZA CLA
	JMP RMODEA

	JMP I RMODE
	
RMODET,	0
MLBASE,	TEXT /----                /
CHGMSG,	TEXT /**/

/ 24-BIT ARITHMETIC. ALL BINARY OPS USE AC24 AND TWO-WORD VALUE
/ POINTED T0 BY WORD FOLLOWING JMS. 24-BIT DOUBLEWORDS ARE
/ LITTLE-ENDIAN, OF COURSE.

P24,	0

/ CLEAR 24-BIT ACCUMULATOR
CLR24,	0
	DCA AC24
	DCA AC24+1
	JMP I CLR24

/ LOAD 24-BIT ACCUMULATOR
LD24,	0
	DCA P24
	TAD I P24
	DCA AC24
	ISZ P24
	TAD I P24
	DCA AC24+1
	JMP I LD24

/STORE 24-BIT ACCUMULATOR
ST24,	0
	DCA P24
	TAD AC24
	DCA I P24
	ISZ P24
	TAD AC24+1
	DCA I P24
	JMP I ST24

/ ADD A 15-BIT POINTER TO AC24, WHICH HOLDS THE RESULT OF
/ A SUB15 OPERATION, TO YIELD A 15-BIT POINTER
ADD15,	0
	DCA P24
	CLL
	TAD AC24
	TAD I P24
	DCA AC24
	ISZ P24
	RTL; RTL
	TAD AC24+1
	TAD I P24
	DCA AC24+1
	JMP I ADD15

/ SUBTRACT TWO 15-BIT POINTERS TO YIELD A DIFFERENCE THAT CAN
/ BE ADDED TO A 15-BIT POINTER, OR FIX24 TO GET A PROPER
/ 15-BIT INTEGER.
SUB15,	0
	DCA P24
	TAD I P24
	CLL CIA
	TAD AC24
	DCA AC24
	ISZ P24
	TAD I P24
	CMA
	SNL
	TAD (-10
	IAC
	TAD AC24+1
	DCA AC24+1
	JMP I SUB15

	PAGE  /-------------------------- 2400

/ FIX AC24 FOR 15-BIT POINTER SUBTRACTIONS THAT YIELD NON-NEGATIVE
/ RESULTS
FIX24,	0
	TAD AC24+1
	CLL RTR; RAR
	DCA AC24+1
	JMP I FIX24

/ WRITE CHAR IN AC TO RENDER BUFFER IF IT FITS
WRRND,	0
	SCRFLD
	DCA I RNDP
	CODFLD
	TAD RNDP
	TAD (-RNDEND+1
	SZA CLA
	ISZ RNDP
	JMP I WRRND
/#EC# SCREEN AND MODE LINE TEXT FUNCTIONS

HALFHT=TXTHT%2

/ SET TOP OF SCREEN. SEARCH BACK LINES FROM POINT UNTIL
/   * FIND LINE CURRENTLY AT TOS. DONE, NO CHANGE
/   * REACH BEGINNING OF BUFFER. SET TOS THERE.
/   * MOVED SCRHT LINES, TOS NOT ON SCREEN, SET TOS
/     TO HALF OF SCRHT LINES BEFORE POINT
SETTOS,	0
	TAD BUF			/ DEFAULT TOS IS BEGINNING OF BUFFER
	DCA NEWTOS
	TAD BUF+1
	DCA NEWTOS+1

	JMS SREVGP
	DCA TOSN		/ ZERO LINE COUNT
	
TOSA,	TAD [NL			/ SEARCH BACK FOR NL
	JMS SREV
	JMP TOSD

	TAD [SRCHP		/ IF WE FOUND THE TOS, WE'RE DONE
	JMS INC15
	TAD [SRCHP
	JMS SNE15; TOS
	JMP I SETTOS

	ISZ TOSN		/ UPDATE LINE COUNT
	TAD TOSN		/ SAVE A GOOD TOS IF WE NEED IT
	TAD (-HALFHT
	SZA CLA
	JMP TOSB
	TAD SRCHP
	DCA NEWTOS
	TAD SRCHP+1
	DCA NEWTOS+1

TOSB,	TAD TOSN		/ GONE BACK SCRHT LINES?
	TAD [-TXTHT
	SNA CLA
	JMP TOSC
	TAD [SRCHP		/ NO, UNDO THE INC15 AND KEEP LOOKING
	JMS DEC15
	JMP TOSA

TOSD,	TAD [TOS		/ COULDN'T FIND ANY NL, TOS ALREADY
	JMS SNE15; BUF
	JMP I SETTOS		/ YES, DONE

TOSC,	TAD NEWTOS		/ SET NEW TOS
	DCA TOS
	TAD NEWTOS+1
	DCA TOS+1
	JMP I SETTOS
	
TOSN,	0	
NEWTOS,	0; 0

/ FORWARD ONE SCREEN.
FWDSCR,	0
	TAD CURROW		/ COMPUTE NUMBER OF LINES TO MOVE
	TAD (-TXTHT-HALFHT+1
	DCA TOSN
	JMS SFWDPT
FWSCA,	TAD [NL			/ NEXT LINE
	JMS SFWD
	JMP FWSCB
	TAD [SRCHP		/ SKIP OVER NL
	JMS INC15
	ISZ TOSN		/ MOVED FAR ENOUGH?
	JMP FWSCA

	JMS GOFWD		/ YES, GO THERE
FWSCC,	ISZ FWDSCR
	JMP I FWDSCR

FWSCB,	TAD TOSN		/ NO NL, IF CURRENT LINE IS NOT
	TAD (HALFHT-1		/ ON SCREEN, MOVE TO END
	SPA CLA
	JMP I FWDSCR
	JMS GOEND
	FAIL
	JMP FWSCC

/ REVERSE ONE SCREEN
REVSCR,	0
	TAD CURROW		/ COMPUTE NUMBER OF LINES TO MOVE
	CIA
	TAD (-HALFHT-1
	DCA TOSN
	JMS SREVGP
RVSCA,	TAD [NL			/ PREVIONS LINE
	JMS SREV
	JMP RVSCB
	ISZ TOSN		/ MOVED FAR ENOUGH?
	JMP RVSCA

	TAD [SRCHP		/ YES, SKIP OVER NL
	JMS INC15
	JMS GOREV		/ GO THERE
RVSCC,	ISZ REVSCR
	JMP I REVSCR

RVSCB,	TAD [TOS		/ CAN'T FIND NL, TOS == BUF?
	JMS SNE15; BUF
	JMP I REVSCR
	JMS GOBEG		/ YES, GO TO BEGINNING
	FAIL
	JMP RVSCC

	PAGE  /-------------------------- 2600

/ SKIP IF AC IS ALPHANUMERIC
SKIPAN,	0
	JMS UPPER
	DCA SKANCH
	TAD SKANCH
	TAD (-60		/ NUMERIC?
	SPA CLA
	JMP SKNAB
	TAD SKANCH
	TAD (-72
	SPA CLA
	JMP SKANA

SKNAB,	TAD SKANCH		/ NO, ALPHA?
	TAD (-101
	SPA CLA
	JMP I SKIPAN
	TAD SKANCH
	TAD (-133
	SPA CLA

SKANA,	ISZ SKIPAN
	JMP I SKIPAN

SKANCH,	0

/ CONVERT 6-BIT ASCII TO 8-BIT
CV68,	 0
	 TAD (40
	 AND [77
	 TAD (40
	 JMP I CV68

/ WRITE 6-BIT STRING TO SUBROUTINE
WR6,	0
	DCA WR6P
	TAD I WR6
	ISZ WR6
	DCA WR6SUB

WR6A,	TAD I WR6P		/ FIRST CHAR
	RTR; RTR; RTR
	AND [77
	SNA
	JMP I WR6
	JMS CV68
	JMS I WR6SUB

	TAD I WR6P		/ SECOND CHAR
	AND [77
	SNA
	JMP I WR6
	JMS CV68
	JMS I WR6SUB
	ISZ WR6P
	JMP WR6A

WR6P,	0
WR6SUB,	0

/ ERASE SCREEN, SET TOS SO THAT CURSOR IS IN MIDDLE OF SCREEN
REDRAW,	0
	JMS SCINIT		/ ERASE
	TAD (HALFHT		/ MOVE TOS
	JMS MOVTOS
	ISZ REDRAW
	JMP I REDRAW

MOVTOS,	0
	CMA
	DCA MVTSN
	JMS SREVGP

MVTSA,	TAD [NL			/ BACK HALF-SCREEN OF LINES
	JMS SREV
	JMP MVTSB
	ISZ MVTSN
	JMP MVTSA

	TAD [SRCHP		/ SKIP OVER NL
	JMS INC15
	TAD SRCHP		/ SET TOS
	DCA TOS
	TAD SRCHP+1
	DCA TOS+1
	JMP I MOVTOS

MVTSB,	TAD BUF			/ NL NOT FOUND, TOS = BUF
	DCA TOS
	TAD BUF+1
	DCA TOS+1
	JMP I MOVTOS

MVTSN,	0

/ DELETE CHARS FROM POINT TO END OF LINE. IF NONE, DELETE
/ NL. FAILS IF NOTHING WAS DELETED (AT END OF BUFFER)
KEOL,	 0
	 JMS SFWDPT		/ FIND EOL
	 TAD [NL
	 JMS SFWD
	 JMP KEOLA

	 TAD [POINT		/ IF AT EOL, DELETE THE NL
	 JMS SNE15; SRCHP
	 SKP
	 JMP KEOLC
	 TAD [SRCHP
	 JMS INC15

KEOLC,	 TAD SRCHP		/ DO THE DELETE
	 DCA POINT
	 TAD SRCHP+1
	 DCA POINT+1

KEOLB,	 ISZ KEOL		/ NORMAL RETURN, SET CHANGED
	 STA
	 DCA CHANGD
	 JMP I KEOL

KEOLA,	 TAD [POINT		/ LAST LINE, ANYTHING TO DELETE?
	 JMS SNE15; BUFEND
	 JMP I KEOL
	 TAD BUFEND		/ YES, DO IT
	 DCA POINT
	 TAD BUFEND+1
	 DCA POINT+1
	 JMP KEOLB

	PAGE  /-------------------------- 3000

/ MODE LINE TEXT
MLTP,	0

/ CLEAR MLT
CLRMLT,	0
	TAD (MLTBUF
	DCA MLTP
	DCA I MLTP
	JMP I CLRMLT

/ WRITE CHARACTER TO MLT, IGNORE IF BUFFER FULL
WRMLT,	0
	DCA I MLTP
	TAD MLTP
	TAD (-MLTEND+1
	SZA CLA
	ISZ MLTP
	DCA I MLTP
	JMP I WRMLT

/ ERASE CHARACTER FROM MLT, IGNORE IF BUFFER EMPTY
ERMLT,	0
	TAD MLTP
	TAD (-MLTBUF
	SNA CLA
	JMP I ERMLT
	STA
	TAD MLTP
	DCA MLTP
	DCA I MLTP
	JMP I ERMLT

/ RENDER MLT. MUST FIT, OVERFLOW NOT CHECKED
RNDMLT,	0
	JMS RNDINI
	TAD (MLTBUF
	DCA MLTP

RMLTA,	TAD I MLTP		/ RENDER EACH CHAR
	SNA
	JMP RMLTB

	TAD (-40		/ CONTROL CHAR?
	SMA CLA
	JMP RMLTC
	TAD (136
	JMS WRRND
	TAD (100

RMLTC,	TAD I MLTP
	JMS WRRND
	ISZ MLTP
	JMP RMLTA

RMLTB,	JMS RNDFIN
	JMP I RNDMLT
